#责任链模式  
类似于公司请假 需要层层审批  
将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链，避免请求发送者与多个请求处理者耦合在一起。当有请求发生的时候  
可以讲请求沿着链传递，直到所有对象处理完它为止。  
结构：  
    抽象处理者（handler）定义处理请求的接口，包含处理方法和一个后续连接
    具体处理者（Concrete Handler）实现抽象处理者，判断是否处理本次请求，如果可以处理则处理，否则转给它的后继者  
    客户端（Client）创建处理链，向链头的具体处理者题叫请求，不关心处理细节和请求的传递过程  

示例的构造太巧妙了，直接通过Handler一个抽象类用于逻辑处理，对于请假day<1 、1< day < 3、3< day <7的情况没有直接用HardCode的方式进行编码，  
而是使用两个变量start和End，和一个**相当于TreeNode节点下一个节点仍然是TreeNode类型**这样又包括本身的作为Next指针，只需要判断是否满足next不为空  
并且当前的请假的end大于当前能审批的end，则直接调用next的同名方法，进行递归。  
这样来说 只需要通过构造起传入固定的start和end，就可以。  巧妙，而且不需要进行很多ifelse的判断  

##责任链模式的优点：  
    降低了发送者和接受者的耦合度（类似于命令模式）  
    增强了系统的可扩展性  满足开闭原则（类似于二叉树）
    增强了给对象指派职责的灵活性  动态改变链内成员或者修改他们的次序，
    责任链模式简化了对象之间的连接 **一个对象只保持一个指向其后续者的引用，避免了众多的If else语句**  
    责任单一（每个类只处理自己该处理的工作，不能处理的传递给下一个对象完成，明确给类的责任范围，符合单一职责原则）  

##缺点：  
    不能保证每一请求被处理。因为没有明确的接收者，可能请求一直传递到链的末端都得不到处理。  
    对于较长的职责链，请求的处理可能设计多个处理对象，系统性能会受到影响  
    职责链的可靠性依赖于客户端的保证，增加了客户端的复杂度，如果错误设置可能会导致系统出错，出现循环调用现象。  
