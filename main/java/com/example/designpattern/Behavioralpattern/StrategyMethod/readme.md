#策略模式 
定义一系列算法，将每个算法封装起来，是他们可以相互替换，且算法的变化不会影响使用的客户。  
通过对算法的封装，将算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。  如开发工具可以选择多种，乘车工具也可以选择多种。  
结构：  
抽象策略类： 给出所有具体策略类所需要的接口  
具体策略类：  提供具体的算法实现或行为  
环境类：  持有一个策略类，最终给客户调用  

##优点：  
策略类之间可以自由切换  
易于扩展，增加只需要添加具体的策略类即可，满足开闭原则  
避免多重选择语句，充份体现面向对象的思想  

##缺点：  
客户端必须知道所有策略类，并自行决定选哪一个  
策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量  
##场景：  
需要动态选择算法中的一种时  
一个类定义了多种行为，并且这些行为在这个类中以条件语句的形式出现，这些行为可以互换  
对客户隐藏具体算法的实现细节，彼此完全独立，互不影响  
多个类需要表现行为不同，可以使用，在运行时动态选择具体要使用的类  

###JDK源码  
Comparator类，在Arrays.sort()方法中使用，传入一个Comparator对象定义排序顺序。  
Arrays是环境角色类，持有抽象策略类的引用（Comparator），具体的策略类是TimSort类中的sort方法