## 单例模式  属于 创建型模式

#单例模式的结构： 单例类和访问类

单例模式的实现：
    1.饿汉式 ： 类加载就会导致该单例对象被创建
    2.懒汉式 ： 类加载不会导致该单例对象被创建，而是首次使用该对象时会被创建

1 - 饿汉式 实现方式
        1 - 1 （静态变量）
        1 - 2 （静态代码块）
对象会随着类的加载而创建，会存在内存浪费的情况。

2 - 懒汉式 实现方式
    2 - 1 线程不安全 多线程时 if(instance == null)线程1进入后，还没有new，线程2执行，进入后会继续new 
    2 - 2 解决方案 使用synchronized关键字
    2 - 3 双重检查锁 绝大多数是读操作，读操作线程安全（锁导致性能问题），调整加锁时机，就是双重检查锁.  

**DCL（Double check Loading），注意需要判断两次if(instance == null)，如线程1判断为null，拿到锁后线程睡眠，线程2判断为null,然后执行创建对象的操作，这时候第二个线程拿到锁创建对象，这样会导致创建的对象不是同一个。  
先判断是否为空，为空进行上锁，再次判断是否为空，依然为空就说明没有一个线程改过，没有线程改动过就进行创建对象
类似于CAS（Compare And Set “比较并交换”**
**同时还需要volatile关键禁止指令重排序，因为创建对象的时候应该先执行构造方法然后进行引用赋值，指令重排序可能导致这两个顺序变化  
引用赋值给new了一半的初始化对象，此时第二个线程来了INSTANCE不为空直接返回，导致数据不一致。所以--需要禁止指令重排序--**

            但是多线程会存在空指针问题，因为JVM实力化对象进行优化和指令重排序  -------推荐使用
    2 - 4 静态内部类 实例由内部类创建，JVM在加载外部类的过程中，不会加载静态内部类，只有内部类的属性/方法被调用才会加载，并初始化其静态属性
            静态内部类由于呗static修饰，保证只被实例化一次，并且严格保证实例化顺序。

3 - 恶汉式 枚举方式 线程安全，只被加载一次，不会被破坏

##破坏单例模式 除了枚举方式 使用序列化和反射就可以破坏
    使用序列化 Serializable 会导致破坏单例模式，拿到是不同的对象
    反射也会破坏

##解决破坏单例模式方法
    解决序列化/反序列化问题 ：在Singleton中添加readResolve()方法，在反序列化时被调用，如果定义了此方法，就返回这个方法的值，如果没有就返回
        新new出来的对象
    反射问题 ： Singleton中使用static的flag判断，如果是非第一次创建，直接跑出异常即可，在使用synchronized关键字修饰字节码既可以保证flag的线程安全