#装饰者模式   
##*巧妙就在于 即继承了类又聚合了类*
定义： 不改变现有对象结构，动态增加一些职责（额外功能）的模式  
**好处：**  
- 装饰模式可以带来比继承更灵活性的扩展功能，使用更方便，可以**组合**不同的装饰者对象，  
来获取具有不同行为状态的多样化结果，比继承更有扩展性，完美符合开闭原则，继承是静态的附加责任，  
装饰者是动态的附加责任
- 装饰者和被装饰者可以独立发展，属于继承的替代模式，可以动态扩展一个实现类的功能
##场景：
    -不能继承时如：系统中大量独立的扩展，若支持每一种组合会产生大量子类，或者类定义的由final修饰（不能继承）
    -在不影响其他对象的情况下，动态透明的给单个对象增加职责
    -在对象的功能要求可以动态的添加和撤销时

##JDK源码涉及：
    -IO流中的包装类 Write
    有两个子类 BufferedWrite和InputStreamWrite，InputStreamWrite子类是FileWrite
    其中BufferedWrite不但继承了Write 还聚合了Write
    使用 类似于new BufferedWrite(new FileWrite()).write();//写数据 

        BufferedWrite使用装饰者模式对Write子实现类增强，添加缓冲区，提供写数据效率

装饰者太巧妙了，如demo1，创建了抽象装饰类Garnish，不但继承了FastFood而且聚合了fastfood  
FriedRice炒米和FriedNoodle炒面都继承自FastFood，而Egg和Bacon（蛋和培根）也都继承自FastFoot  
但是Egg和Bacon属于Garnish具体实现类，在重写方法的时候，比如cost除了加上super.getPrice()获取自身价格  
还通过聚合的FastFoot拿到对应炒米或者炒面的数据。这样就很嵌套的感觉！！！  
---

#静态代理和装饰者区别：  
相同点：  
    -**都要实现目标类相同的接口**  
    -**都要声明目标对象**  
    -都可以在不修改目标类的情况下**增强目标方法**  
不同点：  
    - 目的不同： 装饰者类是为了增强对象， 静态代理是保护和隐藏目标对象
    - 装饰者类的目标对象是外界传入（构造起或者setter方法） 静态代理则是代理类内部创建的，（一般是new出来，隐藏目标对象）