#享元模式  
###运用共享技术支持大量细粒度对象的复用，共享已经存在的对象减少创建的对象数量，提供系统资源的利用率。
 - 有两个状态， 内部状态： 不会随环境改变而改变的可共享部分
 - 外部状态：会随环境改变而改变不可共享的部分。享元模式主要就是区分状态并将外部状态外部化  
结构：
抽象享元角色（FlyWeight）接口或抽象类，声明具体享元类公共的方法，这些方法向外界提供享元对象的内部数据（内部状态），同时也用来设置外部数据（外部状态）
具体享元角色（Concrete FlyWeight）实现抽象享元，为内部状态提供存储空间，通常可以结合单例模式来设计具体享元，为每一个具体享元类提供唯一的享元对象。  
非享元（UnSharable Flyweight）并不是所有的抽象享元类的子类都需要被共享，不需要共享的子类就是非共享具体享元类，可以直接通过实例化构建  
享元工厂（Flyweight Factory）创建和管理享元对象，如果客户请求，先检查系统是否存在符合要求的享元对象，存在返回给客户，否则创建一个新的享元对象。  


###优点：  
    减少内存中相似或者相同对象数量，节约资源，提供系统性能；外部状态相互独立，不影响内部状态  
###缺点：  
    需要将享元对象的部分状态外部化，分离内部状态和外部状态，逻辑复杂

##场景：  
    - 系统中有大量相似或者类似对象，造成内存浪费的
    - 对象的大部分状态都可以外部化，，可以将这些外部状态传入对象中  
    - 使用享元模式需要创建一个存储享元对象的享元池，耗费一定的系统资源，所以自由需要多次重复使用享元对象时才使用该模式。  
#JDK使用实例  
Integer累使用了享元模式，-128 到 127 使用一个对象，大于127使用新的对象。 